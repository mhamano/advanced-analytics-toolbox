{"version":3,"sources":["advanced-analytics-toolbox.js"],"names":["define","qlik","$","cssContent","props","initialProps","ngTemplate","ui","analysis","utils","html","appendTo","createChart","$scope","$compile","app","visualization","layout","selectedAnalysisType","analysisTypes","filter","d","id","analysisTypeId","require","file","hyperCubeCreator","createCube","isMinDimAndMeaUnmet","dimCount","dimensions","length","meaCount","measures","effectiveMinMeas","customMinMeas","minMeas","minDims","i","expression","qStringExpression","checkPreconditions","callback1","callback2","callback3","layoutProps","analysisCategoryId","initialProperties","definition","support","snapshot","export","exportData","template","controller","currApp","undefined","extId","qInfo","qId","patchApplied","chart","setLocaleInfo","compile","$watch","a","b","c","screen","paint","$element","_this","this","self","mode","navigation","getMode","incomplete","_$scope","_$compile","_app","createHtmlElements","drawChart","then","Promise","resolve"],"mappings":"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","file":"../../advanced-analytics-toolbox.js","sourcesContent":["define([\r\n  'qlik',\r\n  'jquery',\r\n  'css!./lib/css/styles.css',\r\n  './properties',\r\n  './initialProperties',\r\n  'text!./advanced-analytics-toolbox.ng.html',\r\n  './lib/js/ui/ui_control',\r\n  './lib/js/analysis/analysis',\r\n  './lib/js/util/utils',\r\n], (qlik, $, cssContent, props, initialProps, ngTemplate, ui, analysis, utils) => {\r\n  // Set style sheet\r\n  $('<style>').html(cssContent).appendTo('head');\r\n\r\n  /**\r\n   * createChart - call createCube function based on the selected analysis type\r\n   *\r\n   * @param {Object} $scope   angular $scope\r\n   * @param {Object} $compile angular $compile\r\n   * @param {Object} app      reference to app\r\n   *\r\n   * @return {Null} null\r\n   */\r\n  const createChart = ($scope, $compile, app) => {\r\n    const visualization = $scope.layout.visualization;\r\n\r\n    const selectedAnalysisType = analysis.analysisTypes.filter((d) => {\r\n      return d.id === $scope.layout.props.analysisTypeId;\r\n    });\r\n    require([`./extensions/${visualization}/lib/js/analysis/${selectedAnalysisType[0].file}`], (hyperCubeCreator) => {\r\n      hyperCubeCreator.createCube(app, $scope);\r\n    });\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * isMinDimAndMeaUnmet - check the number of dimensions and measures\r\n   *                       required for the selected chart type.\r\n   *\r\n   * @param {Object} $scope angular $scope\r\n   *\r\n   * @return {Boolean} Return true if minimum number of dimensions and measures\r\n   *                required for the selected chart type is not met.\r\n   */\r\n  const isMinDimAndMeaUnmet = ($scope) => {\r\n    // Set number of current dim and mea count\r\n    const dimCount = $scope.layout.props.dimensions.length;\r\n    const meaCount = $scope.layout.props.measures.length;\r\n\r\n    // Filter the selected analysis type\r\n    const selectedAnalysisType = analysis.analysisTypes.filter((d) => {\r\n      return d.id === $scope.layout.props.analysisTypeId;\r\n    });\r\n\r\n    // When customMinMeas is set, set it as an effective Minumum Measures count value.\r\n    const effectiveMinMeas = (typeof $scope.customMinMeas == 'undefined' || typeof $scope.customMinMeas[$scope.layout.props.analysisTypeId] == 'undefined') ? selectedAnalysisType[0].minMeas : $scope.customMinMeas[$scope.layout.props.analysisTypeId];\r\n\r\n    if (\r\n      selectedAnalysisType[0].minDims > dimCount ||\r\n      effectiveMinMeas > meaCount\r\n    ) {\r\n      return true;\r\n    }\r\n\r\n    for (let i = 0; i < dimCount; i++) {\r\n      if (typeof $scope.layout.props.dimensions[i].expression.qStringExpression == 'undefined' && $scope.layout.props.dimensions[i].expression === '') { return true; }\r\n    }\r\n\r\n    for (let i = 0; i < meaCount; i++) {\r\n      if (typeof $scope.layout.props.measures[i].expression.qStringExpression == 'undefined' && $scope.layout.props.measures[i].expression === '') { return true; }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * checkPreconditions - Check precondition for rendering charts.\r\n   *\r\n   * @param {Object} $scope    angular $scope\r\n   * @param {Object} $compile  angular $compile\r\n   * @param {Object} app       reference to app\r\n   * @param {Object} callback1 called when analysis category and type is not selected.\r\n   * @param {Object} callback2 called when requirement for minumum dimension and measure is not met.\r\n   * @param {Object} callback3 called when all requirements for chart rendering is met\r\n   *\r\n   * @return {Null} null\r\n   */\r\n  const checkPreconditions = ($scope, $compile, app, callback1, callback2, callback3) => {\r\n    const layoutProps = $scope.layout.props;\r\n    if (layoutProps.analysisCategoryId === -1 || layoutProps.analysisTypeId === -1) {\r\n      callback1($scope, $compile, app);\r\n    } else if (isMinDimAndMeaUnmet($scope)) {\r\n      callback2($scope, $compile, app);\r\n    } else {\r\n      callback3($scope, $compile, app);\r\n    }\r\n    return null;\r\n  };\r\n\r\n  return {\r\n    initialProperties: initialProps,\r\n    definition: props,\r\n    support: {\r\n      snapshot: true,\r\n      export: false,\r\n      exportData: true,\r\n    },\r\n    template: ngTemplate,\r\n    // Controller\r\n    controller: ['$scope', '$compile', ($scope, $compile) => {\r\n      // Get a reference to app\r\n      const app = qlik.currApp(this);\r\n\r\n      // Set extension id\r\n      $scope.extId = $scope.layout.qInfo.qId;\r\n\r\n      // Set patch applied flat.\r\n      $scope.patchApplied = false;\r\n\r\n      // Create variable to store chart\r\n      $scope.chart = [];\r\n\r\n      // Get number format (thousand separators, decimal separators, etc) from locale info\r\n      utils.setLocaleInfo($scope, app);\r\n\r\n      // Store $compile under $scope to be accessible from paint method\r\n      $scope.compile = $compile;\r\n\r\n      // Watch the change of the settings on property panel\r\n      $scope.$watch('layout.props', (layoutProps) => {\r\n        checkPreconditions(\r\n          $scope, $compile, app,\r\n          (a, b, c) => {\r\n            $scope.screen = 0;\r\n            // create HTML is called in paint\r\n            // ui.createHtmlElements(a, b, c);\r\n          },\r\n          (a, b, c) => {\r\n            $scope.screen = 1;\r\n            // create HTML is called in paint\r\n            // ui.createHtmlElements(a, b, c);\r\n          },\r\n          (a, b, c) => {\r\n            createChart(a, b, c);\r\n          },\r\n        );\r\n      }, true);\r\n    }],\r\n    // Paint\r\n    paint($element, layout) {\r\n      // Get a reference to app\r\n      const app = qlik.currApp(this);\r\n\r\n      this.$scope.self = this;\r\n\r\n      // Set a flag to display 'Incomplete visualization' in 'analysis' mode.\r\n      // In 'edit' mode, a chart or buttons for settings are displayed.\r\n      const mode = qlik.navigation.getMode();\r\n      if (mode === 'analysis') {\r\n        this.$scope.incomplete = true;\r\n      } else {\r\n        this.$scope.incomplete = false;\r\n      }\r\n\r\n      // Create HTML element when analysis category and type is not selected,\r\n      // or when min dim and mea requirements are not met.\r\n      checkPreconditions(\r\n        this.$scope, this.$scope.compile, app,\r\n        (_$scope, _$compile, _app) =>  {\r\n          this.$scope.screen = 0;\r\n          ui.createHtmlElements(_$scope, _$compile, _app);\r\n        },\r\n        (_$scope, _$compile, _app) =>  {\r\n          this.$scope.screen = 1;\r\n          ui.createHtmlElements(_$scope, _$compile, _app);\r\n        },\r\n        () => {}, // Ignore when a chart is displayed\r\n      );\r\n\r\n      // drawChart is called only when patchApplied flag is true to avoid called\r\n      // twice: initial paint call and paint method called when patch applied.\r\n      // Leave the flag true after initial call because paint method is called\r\n      // when record selections and drawChart need to be called.\r\n      if (this.$scope.patchApplied) {\r\n        // Retrieve updated data and redraw the chart with the data\r\n        checkPreconditions(\r\n          this.$scope, this.$compile, app,\r\n          () => {}, // Ignore when analysis category and type is not selected.\r\n          () => {}, // Ignore when min dim and mea requirements are not met.\r\n          (_$scope, _$compile, _app) => {\r\n            const visualization = _$scope.layout.visualization;\r\n\r\n            // Filter the selected analysis type\r\n            const selectedAnalysisType = analysis.analysisTypes.filter((d) => {\r\n              return d.id === _$scope.layout.props.analysisTypeId;\r\n            });\r\n            require([`./extensions/${visualization}/lib/js/analysis/${selectedAnalysisType[0].file}`], (hyperCubeCreator) => {\r\n              hyperCubeCreator.drawChart(_$scope, _app).then(() => {\r\n                return qlik.Promise.resolve();\r\n              });\r\n            });\r\n          },\r\n        );\r\n      } // end of if\r\n    },\r\n  };\r\n});\r\n"]}